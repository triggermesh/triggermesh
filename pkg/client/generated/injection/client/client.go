/*
Copyright 2021 TriggerMesh Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package client

import (
	context "context"
	json "encoding/json"
	errors "errors"
	fmt "fmt"

	v1alpha1 "github.com/triggermesh/triggermesh/pkg/apis/extensions/v1alpha1"
	flowv1alpha1 "github.com/triggermesh/triggermesh/pkg/apis/flow/v1alpha1"
	routingv1alpha1 "github.com/triggermesh/triggermesh/pkg/apis/routing/v1alpha1"
	sourcesv1alpha1 "github.com/triggermesh/triggermesh/pkg/apis/sources/v1alpha1"
	targetsv1alpha1 "github.com/triggermesh/triggermesh/pkg/apis/targets/v1alpha1"
	internalclientset "github.com/triggermesh/triggermesh/pkg/client/generated/clientset/internalclientset"
	typedextensionsv1alpha1 "github.com/triggermesh/triggermesh/pkg/client/generated/clientset/internalclientset/typed/extensions/v1alpha1"
	typedflowv1alpha1 "github.com/triggermesh/triggermesh/pkg/client/generated/clientset/internalclientset/typed/flow/v1alpha1"
	typedroutingv1alpha1 "github.com/triggermesh/triggermesh/pkg/client/generated/clientset/internalclientset/typed/routing/v1alpha1"
	typedsourcesv1alpha1 "github.com/triggermesh/triggermesh/pkg/client/generated/clientset/internalclientset/typed/sources/v1alpha1"
	typedtargetsv1alpha1 "github.com/triggermesh/triggermesh/pkg/client/generated/clientset/internalclientset/typed/targets/v1alpha1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	unstructured "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	runtime "k8s.io/apimachinery/pkg/runtime"
	schema "k8s.io/apimachinery/pkg/runtime/schema"
	types "k8s.io/apimachinery/pkg/types"
	watch "k8s.io/apimachinery/pkg/watch"
	discovery "k8s.io/client-go/discovery"
	dynamic "k8s.io/client-go/dynamic"
	rest "k8s.io/client-go/rest"
	injection "knative.dev/pkg/injection"
	dynamicclient "knative.dev/pkg/injection/clients/dynamicclient"
	logging "knative.dev/pkg/logging"
)

func init() {
	injection.Default.RegisterClient(withClientFromConfig)
	injection.Default.RegisterClientFetcher(func(ctx context.Context) interface{} {
		return Get(ctx)
	})
	injection.Dynamic.RegisterDynamicClient(withClientFromDynamic)
}

// Key is used as the key for associating information with a context.Context.
type Key struct{}

func withClientFromConfig(ctx context.Context, cfg *rest.Config) context.Context {
	return context.WithValue(ctx, Key{}, internalclientset.NewForConfigOrDie(cfg))
}

func withClientFromDynamic(ctx context.Context) context.Context {
	return context.WithValue(ctx, Key{}, &wrapClient{dyn: dynamicclient.Get(ctx)})
}

// Get extracts the internalclientset.Interface client from the context.
func Get(ctx context.Context) internalclientset.Interface {
	untyped := ctx.Value(Key{})
	if untyped == nil {
		if injection.GetConfig(ctx) == nil {
			logging.FromContext(ctx).Panic(
				"Unable to fetch github.com/triggermesh/triggermesh/pkg/client/generated/clientset/internalclientset.Interface from context. This context is not the application context (which is typically given to constructors via sharedmain).")
		} else {
			logging.FromContext(ctx).Panic(
				"Unable to fetch github.com/triggermesh/triggermesh/pkg/client/generated/clientset/internalclientset.Interface from context.")
		}
	}
	return untyped.(internalclientset.Interface)
}

type wrapClient struct {
	dyn dynamic.Interface
}

var _ internalclientset.Interface = (*wrapClient)(nil)

func (w *wrapClient) Discovery() discovery.DiscoveryInterface {
	panic("Discovery called on dynamic client!")
}

func convert(from interface{}, to runtime.Object) error {
	bs, err := json.Marshal(from)
	if err != nil {
		return fmt.Errorf("Marshal() = %w", err)
	}
	if err := json.Unmarshal(bs, to); err != nil {
		return fmt.Errorf("Unmarshal() = %w", err)
	}
	return nil
}

// ExtensionsV1alpha1 retrieves the ExtensionsV1alpha1Client
func (w *wrapClient) ExtensionsV1alpha1() typedextensionsv1alpha1.ExtensionsV1alpha1Interface {
	return &wrapExtensionsV1alpha1{
		dyn: w.dyn,
	}
}

type wrapExtensionsV1alpha1 struct {
	dyn dynamic.Interface
}

func (w *wrapExtensionsV1alpha1) RESTClient() rest.Interface {
	panic("RESTClient called on dynamic client!")
}

func (w *wrapExtensionsV1alpha1) Functions(namespace string) typedextensionsv1alpha1.FunctionInterface {
	return &wrapExtensionsV1alpha1FunctionImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "extensions.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "functions",
		}),

		namespace: namespace,
	}
}

type wrapExtensionsV1alpha1FunctionImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedextensionsv1alpha1.FunctionInterface = (*wrapExtensionsV1alpha1FunctionImpl)(nil)

func (w *wrapExtensionsV1alpha1FunctionImpl) Create(ctx context.Context, in *v1alpha1.Function, opts v1.CreateOptions) (*v1alpha1.Function, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "extensions.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "Function",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Function{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapExtensionsV1alpha1FunctionImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapExtensionsV1alpha1FunctionImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapExtensionsV1alpha1FunctionImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.Function, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Function{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapExtensionsV1alpha1FunctionImpl) List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.FunctionList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.FunctionList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapExtensionsV1alpha1FunctionImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.Function, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Function{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapExtensionsV1alpha1FunctionImpl) Update(ctx context.Context, in *v1alpha1.Function, opts v1.UpdateOptions) (*v1alpha1.Function, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "extensions.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "Function",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Function{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapExtensionsV1alpha1FunctionImpl) UpdateStatus(ctx context.Context, in *v1alpha1.Function, opts v1.UpdateOptions) (*v1alpha1.Function, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "extensions.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "Function",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Function{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapExtensionsV1alpha1FunctionImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

// FlowV1alpha1 retrieves the FlowV1alpha1Client
func (w *wrapClient) FlowV1alpha1() typedflowv1alpha1.FlowV1alpha1Interface {
	return &wrapFlowV1alpha1{
		dyn: w.dyn,
	}
}

type wrapFlowV1alpha1 struct {
	dyn dynamic.Interface
}

func (w *wrapFlowV1alpha1) RESTClient() rest.Interface {
	panic("RESTClient called on dynamic client!")
}

func (w *wrapFlowV1alpha1) Synchronizers(namespace string) typedflowv1alpha1.SynchronizerInterface {
	return &wrapFlowV1alpha1SynchronizerImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "flow.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "synchronizers",
		}),

		namespace: namespace,
	}
}

type wrapFlowV1alpha1SynchronizerImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedflowv1alpha1.SynchronizerInterface = (*wrapFlowV1alpha1SynchronizerImpl)(nil)

func (w *wrapFlowV1alpha1SynchronizerImpl) Create(ctx context.Context, in *flowv1alpha1.Synchronizer, opts v1.CreateOptions) (*flowv1alpha1.Synchronizer, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "flow.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "Synchronizer",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.Synchronizer{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1SynchronizerImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapFlowV1alpha1SynchronizerImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapFlowV1alpha1SynchronizerImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*flowv1alpha1.Synchronizer, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.Synchronizer{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1SynchronizerImpl) List(ctx context.Context, opts v1.ListOptions) (*flowv1alpha1.SynchronizerList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.SynchronizerList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1SynchronizerImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *flowv1alpha1.Synchronizer, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.Synchronizer{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1SynchronizerImpl) Update(ctx context.Context, in *flowv1alpha1.Synchronizer, opts v1.UpdateOptions) (*flowv1alpha1.Synchronizer, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "flow.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "Synchronizer",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.Synchronizer{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1SynchronizerImpl) UpdateStatus(ctx context.Context, in *flowv1alpha1.Synchronizer, opts v1.UpdateOptions) (*flowv1alpha1.Synchronizer, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "flow.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "Synchronizer",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.Synchronizer{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1SynchronizerImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapFlowV1alpha1) Transformations(namespace string) typedflowv1alpha1.TransformationInterface {
	return &wrapFlowV1alpha1TransformationImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "flow.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "transformations",
		}),

		namespace: namespace,
	}
}

type wrapFlowV1alpha1TransformationImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedflowv1alpha1.TransformationInterface = (*wrapFlowV1alpha1TransformationImpl)(nil)

func (w *wrapFlowV1alpha1TransformationImpl) Create(ctx context.Context, in *flowv1alpha1.Transformation, opts v1.CreateOptions) (*flowv1alpha1.Transformation, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "flow.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "Transformation",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.Transformation{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1TransformationImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapFlowV1alpha1TransformationImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapFlowV1alpha1TransformationImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*flowv1alpha1.Transformation, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.Transformation{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1TransformationImpl) List(ctx context.Context, opts v1.ListOptions) (*flowv1alpha1.TransformationList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.TransformationList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1TransformationImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *flowv1alpha1.Transformation, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.Transformation{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1TransformationImpl) Update(ctx context.Context, in *flowv1alpha1.Transformation, opts v1.UpdateOptions) (*flowv1alpha1.Transformation, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "flow.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "Transformation",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.Transformation{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1TransformationImpl) UpdateStatus(ctx context.Context, in *flowv1alpha1.Transformation, opts v1.UpdateOptions) (*flowv1alpha1.Transformation, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "flow.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "Transformation",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.Transformation{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1TransformationImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapFlowV1alpha1) XMLToJSONTransformations(namespace string) typedflowv1alpha1.XMLToJSONTransformationInterface {
	return &wrapFlowV1alpha1XMLToJSONTransformationImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "flow.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "xmltojsontransformations",
		}),

		namespace: namespace,
	}
}

type wrapFlowV1alpha1XMLToJSONTransformationImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedflowv1alpha1.XMLToJSONTransformationInterface = (*wrapFlowV1alpha1XMLToJSONTransformationImpl)(nil)

func (w *wrapFlowV1alpha1XMLToJSONTransformationImpl) Create(ctx context.Context, in *flowv1alpha1.XMLToJSONTransformation, opts v1.CreateOptions) (*flowv1alpha1.XMLToJSONTransformation, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "flow.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "XMLToJSONTransformation",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.XMLToJSONTransformation{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1XMLToJSONTransformationImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapFlowV1alpha1XMLToJSONTransformationImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapFlowV1alpha1XMLToJSONTransformationImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*flowv1alpha1.XMLToJSONTransformation, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.XMLToJSONTransformation{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1XMLToJSONTransformationImpl) List(ctx context.Context, opts v1.ListOptions) (*flowv1alpha1.XMLToJSONTransformationList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.XMLToJSONTransformationList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1XMLToJSONTransformationImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *flowv1alpha1.XMLToJSONTransformation, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.XMLToJSONTransformation{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1XMLToJSONTransformationImpl) Update(ctx context.Context, in *flowv1alpha1.XMLToJSONTransformation, opts v1.UpdateOptions) (*flowv1alpha1.XMLToJSONTransformation, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "flow.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "XMLToJSONTransformation",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.XMLToJSONTransformation{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1XMLToJSONTransformationImpl) UpdateStatus(ctx context.Context, in *flowv1alpha1.XMLToJSONTransformation, opts v1.UpdateOptions) (*flowv1alpha1.XMLToJSONTransformation, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "flow.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "XMLToJSONTransformation",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.XMLToJSONTransformation{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1XMLToJSONTransformationImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapFlowV1alpha1) XSLTTransforms(namespace string) typedflowv1alpha1.XSLTTransformInterface {
	return &wrapFlowV1alpha1XSLTTransformImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "flow.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "xslttransforms",
		}),

		namespace: namespace,
	}
}

type wrapFlowV1alpha1XSLTTransformImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedflowv1alpha1.XSLTTransformInterface = (*wrapFlowV1alpha1XSLTTransformImpl)(nil)

func (w *wrapFlowV1alpha1XSLTTransformImpl) Create(ctx context.Context, in *flowv1alpha1.XSLTTransform, opts v1.CreateOptions) (*flowv1alpha1.XSLTTransform, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "flow.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "XSLTTransform",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.XSLTTransform{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1XSLTTransformImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapFlowV1alpha1XSLTTransformImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapFlowV1alpha1XSLTTransformImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*flowv1alpha1.XSLTTransform, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.XSLTTransform{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1XSLTTransformImpl) List(ctx context.Context, opts v1.ListOptions) (*flowv1alpha1.XSLTTransformList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.XSLTTransformList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1XSLTTransformImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *flowv1alpha1.XSLTTransform, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.XSLTTransform{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1XSLTTransformImpl) Update(ctx context.Context, in *flowv1alpha1.XSLTTransform, opts v1.UpdateOptions) (*flowv1alpha1.XSLTTransform, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "flow.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "XSLTTransform",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.XSLTTransform{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1XSLTTransformImpl) UpdateStatus(ctx context.Context, in *flowv1alpha1.XSLTTransform, opts v1.UpdateOptions) (*flowv1alpha1.XSLTTransform, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "flow.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "XSLTTransform",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &flowv1alpha1.XSLTTransform{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapFlowV1alpha1XSLTTransformImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

// RoutingV1alpha1 retrieves the RoutingV1alpha1Client
func (w *wrapClient) RoutingV1alpha1() typedroutingv1alpha1.RoutingV1alpha1Interface {
	return &wrapRoutingV1alpha1{
		dyn: w.dyn,
	}
}

type wrapRoutingV1alpha1 struct {
	dyn dynamic.Interface
}

func (w *wrapRoutingV1alpha1) RESTClient() rest.Interface {
	panic("RESTClient called on dynamic client!")
}

func (w *wrapRoutingV1alpha1) Filters(namespace string) typedroutingv1alpha1.FilterInterface {
	return &wrapRoutingV1alpha1FilterImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "routing.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "filters",
		}),

		namespace: namespace,
	}
}

type wrapRoutingV1alpha1FilterImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedroutingv1alpha1.FilterInterface = (*wrapRoutingV1alpha1FilterImpl)(nil)

func (w *wrapRoutingV1alpha1FilterImpl) Create(ctx context.Context, in *routingv1alpha1.Filter, opts v1.CreateOptions) (*routingv1alpha1.Filter, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "routing.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "Filter",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &routingv1alpha1.Filter{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRoutingV1alpha1FilterImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapRoutingV1alpha1FilterImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapRoutingV1alpha1FilterImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*routingv1alpha1.Filter, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &routingv1alpha1.Filter{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRoutingV1alpha1FilterImpl) List(ctx context.Context, opts v1.ListOptions) (*routingv1alpha1.FilterList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &routingv1alpha1.FilterList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRoutingV1alpha1FilterImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *routingv1alpha1.Filter, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &routingv1alpha1.Filter{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRoutingV1alpha1FilterImpl) Update(ctx context.Context, in *routingv1alpha1.Filter, opts v1.UpdateOptions) (*routingv1alpha1.Filter, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "routing.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "Filter",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &routingv1alpha1.Filter{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRoutingV1alpha1FilterImpl) UpdateStatus(ctx context.Context, in *routingv1alpha1.Filter, opts v1.UpdateOptions) (*routingv1alpha1.Filter, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "routing.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "Filter",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &routingv1alpha1.Filter{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRoutingV1alpha1FilterImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapRoutingV1alpha1) Splitters(namespace string) typedroutingv1alpha1.SplitterInterface {
	return &wrapRoutingV1alpha1SplitterImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "routing.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "splitters",
		}),

		namespace: namespace,
	}
}

type wrapRoutingV1alpha1SplitterImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedroutingv1alpha1.SplitterInterface = (*wrapRoutingV1alpha1SplitterImpl)(nil)

func (w *wrapRoutingV1alpha1SplitterImpl) Create(ctx context.Context, in *routingv1alpha1.Splitter, opts v1.CreateOptions) (*routingv1alpha1.Splitter, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "routing.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "Splitter",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &routingv1alpha1.Splitter{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRoutingV1alpha1SplitterImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapRoutingV1alpha1SplitterImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapRoutingV1alpha1SplitterImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*routingv1alpha1.Splitter, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &routingv1alpha1.Splitter{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRoutingV1alpha1SplitterImpl) List(ctx context.Context, opts v1.ListOptions) (*routingv1alpha1.SplitterList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &routingv1alpha1.SplitterList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRoutingV1alpha1SplitterImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *routingv1alpha1.Splitter, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &routingv1alpha1.Splitter{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRoutingV1alpha1SplitterImpl) Update(ctx context.Context, in *routingv1alpha1.Splitter, opts v1.UpdateOptions) (*routingv1alpha1.Splitter, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "routing.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "Splitter",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &routingv1alpha1.Splitter{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRoutingV1alpha1SplitterImpl) UpdateStatus(ctx context.Context, in *routingv1alpha1.Splitter, opts v1.UpdateOptions) (*routingv1alpha1.Splitter, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "routing.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "Splitter",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &routingv1alpha1.Splitter{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRoutingV1alpha1SplitterImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

// SourcesV1alpha1 retrieves the SourcesV1alpha1Client
func (w *wrapClient) SourcesV1alpha1() typedsourcesv1alpha1.SourcesV1alpha1Interface {
	return &wrapSourcesV1alpha1{
		dyn: w.dyn,
	}
}

type wrapSourcesV1alpha1 struct {
	dyn dynamic.Interface
}

func (w *wrapSourcesV1alpha1) RESTClient() rest.Interface {
	panic("RESTClient called on dynamic client!")
}

func (w *wrapSourcesV1alpha1) AWSCloudWatchLogsSources(namespace string) typedsourcesv1alpha1.AWSCloudWatchLogsSourceInterface {
	return &wrapSourcesV1alpha1AWSCloudWatchLogsSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awscloudwatchlogssources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AWSCloudWatchLogsSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AWSCloudWatchLogsSourceInterface = (*wrapSourcesV1alpha1AWSCloudWatchLogsSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AWSCloudWatchLogsSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AWSCloudWatchLogsSource, opts v1.CreateOptions) (*sourcesv1alpha1.AWSCloudWatchLogsSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSCloudWatchLogsSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCloudWatchLogsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCloudWatchLogsSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AWSCloudWatchLogsSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AWSCloudWatchLogsSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AWSCloudWatchLogsSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCloudWatchLogsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCloudWatchLogsSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AWSCloudWatchLogsSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCloudWatchLogsSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCloudWatchLogsSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AWSCloudWatchLogsSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCloudWatchLogsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCloudWatchLogsSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AWSCloudWatchLogsSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSCloudWatchLogsSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSCloudWatchLogsSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCloudWatchLogsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCloudWatchLogsSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AWSCloudWatchLogsSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSCloudWatchLogsSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSCloudWatchLogsSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCloudWatchLogsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCloudWatchLogsSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AWSCloudWatchSources(namespace string) typedsourcesv1alpha1.AWSCloudWatchSourceInterface {
	return &wrapSourcesV1alpha1AWSCloudWatchSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awscloudwatchsources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AWSCloudWatchSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AWSCloudWatchSourceInterface = (*wrapSourcesV1alpha1AWSCloudWatchSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AWSCloudWatchSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AWSCloudWatchSource, opts v1.CreateOptions) (*sourcesv1alpha1.AWSCloudWatchSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSCloudWatchSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCloudWatchSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCloudWatchSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AWSCloudWatchSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AWSCloudWatchSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AWSCloudWatchSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCloudWatchSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCloudWatchSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AWSCloudWatchSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCloudWatchSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCloudWatchSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AWSCloudWatchSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCloudWatchSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCloudWatchSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AWSCloudWatchSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSCloudWatchSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSCloudWatchSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCloudWatchSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCloudWatchSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AWSCloudWatchSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSCloudWatchSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSCloudWatchSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCloudWatchSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCloudWatchSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AWSCodeCommitSources(namespace string) typedsourcesv1alpha1.AWSCodeCommitSourceInterface {
	return &wrapSourcesV1alpha1AWSCodeCommitSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awscodecommitsources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AWSCodeCommitSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AWSCodeCommitSourceInterface = (*wrapSourcesV1alpha1AWSCodeCommitSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AWSCodeCommitSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AWSCodeCommitSource, opts v1.CreateOptions) (*sourcesv1alpha1.AWSCodeCommitSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSCodeCommitSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCodeCommitSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCodeCommitSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AWSCodeCommitSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AWSCodeCommitSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AWSCodeCommitSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCodeCommitSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCodeCommitSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AWSCodeCommitSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCodeCommitSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCodeCommitSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AWSCodeCommitSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCodeCommitSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCodeCommitSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AWSCodeCommitSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSCodeCommitSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSCodeCommitSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCodeCommitSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCodeCommitSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AWSCodeCommitSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSCodeCommitSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSCodeCommitSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCodeCommitSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCodeCommitSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AWSCognitoIdentitySources(namespace string) typedsourcesv1alpha1.AWSCognitoIdentitySourceInterface {
	return &wrapSourcesV1alpha1AWSCognitoIdentitySourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awscognitoidentitysources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AWSCognitoIdentitySourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AWSCognitoIdentitySourceInterface = (*wrapSourcesV1alpha1AWSCognitoIdentitySourceImpl)(nil)

func (w *wrapSourcesV1alpha1AWSCognitoIdentitySourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AWSCognitoIdentitySource, opts v1.CreateOptions) (*sourcesv1alpha1.AWSCognitoIdentitySource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSCognitoIdentitySource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCognitoIdentitySource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCognitoIdentitySourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AWSCognitoIdentitySourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AWSCognitoIdentitySourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AWSCognitoIdentitySource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCognitoIdentitySource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCognitoIdentitySourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AWSCognitoIdentitySourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCognitoIdentitySourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCognitoIdentitySourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AWSCognitoIdentitySource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCognitoIdentitySource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCognitoIdentitySourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AWSCognitoIdentitySource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSCognitoIdentitySource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSCognitoIdentitySource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCognitoIdentitySource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCognitoIdentitySourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AWSCognitoIdentitySource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSCognitoIdentitySource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSCognitoIdentitySource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCognitoIdentitySource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCognitoIdentitySourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AWSCognitoUserPoolSources(namespace string) typedsourcesv1alpha1.AWSCognitoUserPoolSourceInterface {
	return &wrapSourcesV1alpha1AWSCognitoUserPoolSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awscognitouserpoolsources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AWSCognitoUserPoolSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AWSCognitoUserPoolSourceInterface = (*wrapSourcesV1alpha1AWSCognitoUserPoolSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AWSCognitoUserPoolSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AWSCognitoUserPoolSource, opts v1.CreateOptions) (*sourcesv1alpha1.AWSCognitoUserPoolSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSCognitoUserPoolSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCognitoUserPoolSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCognitoUserPoolSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AWSCognitoUserPoolSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AWSCognitoUserPoolSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AWSCognitoUserPoolSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCognitoUserPoolSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCognitoUserPoolSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AWSCognitoUserPoolSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCognitoUserPoolSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCognitoUserPoolSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AWSCognitoUserPoolSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCognitoUserPoolSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCognitoUserPoolSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AWSCognitoUserPoolSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSCognitoUserPoolSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSCognitoUserPoolSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCognitoUserPoolSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCognitoUserPoolSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AWSCognitoUserPoolSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSCognitoUserPoolSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSCognitoUserPoolSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSCognitoUserPoolSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSCognitoUserPoolSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AWSDynamoDBSources(namespace string) typedsourcesv1alpha1.AWSDynamoDBSourceInterface {
	return &wrapSourcesV1alpha1AWSDynamoDBSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awsdynamodbsources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AWSDynamoDBSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AWSDynamoDBSourceInterface = (*wrapSourcesV1alpha1AWSDynamoDBSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AWSDynamoDBSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AWSDynamoDBSource, opts v1.CreateOptions) (*sourcesv1alpha1.AWSDynamoDBSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSDynamoDBSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSDynamoDBSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSDynamoDBSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AWSDynamoDBSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AWSDynamoDBSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AWSDynamoDBSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSDynamoDBSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSDynamoDBSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AWSDynamoDBSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSDynamoDBSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSDynamoDBSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AWSDynamoDBSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSDynamoDBSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSDynamoDBSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AWSDynamoDBSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSDynamoDBSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSDynamoDBSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSDynamoDBSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSDynamoDBSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AWSDynamoDBSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSDynamoDBSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSDynamoDBSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSDynamoDBSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSDynamoDBSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AWSKinesisSources(namespace string) typedsourcesv1alpha1.AWSKinesisSourceInterface {
	return &wrapSourcesV1alpha1AWSKinesisSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awskinesissources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AWSKinesisSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AWSKinesisSourceInterface = (*wrapSourcesV1alpha1AWSKinesisSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AWSKinesisSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AWSKinesisSource, opts v1.CreateOptions) (*sourcesv1alpha1.AWSKinesisSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSKinesisSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSKinesisSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSKinesisSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AWSKinesisSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AWSKinesisSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AWSKinesisSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSKinesisSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSKinesisSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AWSKinesisSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSKinesisSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSKinesisSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AWSKinesisSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSKinesisSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSKinesisSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AWSKinesisSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSKinesisSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSKinesisSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSKinesisSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSKinesisSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AWSKinesisSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSKinesisSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSKinesisSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSKinesisSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSKinesisSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AWSPerformanceInsightsSources(namespace string) typedsourcesv1alpha1.AWSPerformanceInsightsSourceInterface {
	return &wrapSourcesV1alpha1AWSPerformanceInsightsSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awsperformanceinsightssources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AWSPerformanceInsightsSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AWSPerformanceInsightsSourceInterface = (*wrapSourcesV1alpha1AWSPerformanceInsightsSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AWSPerformanceInsightsSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AWSPerformanceInsightsSource, opts v1.CreateOptions) (*sourcesv1alpha1.AWSPerformanceInsightsSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSPerformanceInsightsSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSPerformanceInsightsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSPerformanceInsightsSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AWSPerformanceInsightsSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AWSPerformanceInsightsSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AWSPerformanceInsightsSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSPerformanceInsightsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSPerformanceInsightsSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AWSPerformanceInsightsSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSPerformanceInsightsSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSPerformanceInsightsSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AWSPerformanceInsightsSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSPerformanceInsightsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSPerformanceInsightsSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AWSPerformanceInsightsSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSPerformanceInsightsSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSPerformanceInsightsSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSPerformanceInsightsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSPerformanceInsightsSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AWSPerformanceInsightsSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSPerformanceInsightsSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSPerformanceInsightsSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSPerformanceInsightsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSPerformanceInsightsSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AWSS3Sources(namespace string) typedsourcesv1alpha1.AWSS3SourceInterface {
	return &wrapSourcesV1alpha1AWSS3SourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awss3sources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AWSS3SourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AWSS3SourceInterface = (*wrapSourcesV1alpha1AWSS3SourceImpl)(nil)

func (w *wrapSourcesV1alpha1AWSS3SourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AWSS3Source, opts v1.CreateOptions) (*sourcesv1alpha1.AWSS3Source, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSS3Source",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSS3Source{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSS3SourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AWSS3SourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AWSS3SourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AWSS3Source, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSS3Source{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSS3SourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AWSS3SourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSS3SourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSS3SourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AWSS3Source, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSS3Source{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSS3SourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AWSS3Source, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSS3Source, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSS3Source",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSS3Source{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSS3SourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AWSS3Source, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSS3Source, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSS3Source",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSS3Source{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSS3SourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AWSSNSSources(namespace string) typedsourcesv1alpha1.AWSSNSSourceInterface {
	return &wrapSourcesV1alpha1AWSSNSSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awssnssources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AWSSNSSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AWSSNSSourceInterface = (*wrapSourcesV1alpha1AWSSNSSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AWSSNSSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AWSSNSSource, opts v1.CreateOptions) (*sourcesv1alpha1.AWSSNSSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSSNSSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSSNSSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSSNSSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AWSSNSSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AWSSNSSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AWSSNSSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSSNSSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSSNSSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AWSSNSSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSSNSSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSSNSSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AWSSNSSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSSNSSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSSNSSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AWSSNSSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSSNSSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSSNSSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSSNSSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSSNSSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AWSSNSSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSSNSSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSSNSSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSSNSSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSSNSSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AWSSQSSources(namespace string) typedsourcesv1alpha1.AWSSQSSourceInterface {
	return &wrapSourcesV1alpha1AWSSQSSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awssqssources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AWSSQSSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AWSSQSSourceInterface = (*wrapSourcesV1alpha1AWSSQSSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AWSSQSSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AWSSQSSource, opts v1.CreateOptions) (*sourcesv1alpha1.AWSSQSSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSSQSSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSSQSSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSSQSSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AWSSQSSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AWSSQSSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AWSSQSSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSSQSSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSSQSSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AWSSQSSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSSQSSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSSQSSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AWSSQSSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSSQSSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSSQSSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AWSSQSSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSSQSSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSSQSSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSSQSSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSSQSSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AWSSQSSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AWSSQSSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSSQSSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AWSSQSSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AWSSQSSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AzureActivityLogsSources(namespace string) typedsourcesv1alpha1.AzureActivityLogsSourceInterface {
	return &wrapSourcesV1alpha1AzureActivityLogsSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "azureactivitylogssources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AzureActivityLogsSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AzureActivityLogsSourceInterface = (*wrapSourcesV1alpha1AzureActivityLogsSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AzureActivityLogsSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AzureActivityLogsSource, opts v1.CreateOptions) (*sourcesv1alpha1.AzureActivityLogsSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureActivityLogsSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureActivityLogsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureActivityLogsSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AzureActivityLogsSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AzureActivityLogsSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AzureActivityLogsSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureActivityLogsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureActivityLogsSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AzureActivityLogsSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureActivityLogsSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureActivityLogsSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AzureActivityLogsSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureActivityLogsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureActivityLogsSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AzureActivityLogsSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureActivityLogsSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureActivityLogsSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureActivityLogsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureActivityLogsSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AzureActivityLogsSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureActivityLogsSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureActivityLogsSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureActivityLogsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureActivityLogsSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AzureBlobStorageSources(namespace string) typedsourcesv1alpha1.AzureBlobStorageSourceInterface {
	return &wrapSourcesV1alpha1AzureBlobStorageSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "azureblobstoragesources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AzureBlobStorageSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AzureBlobStorageSourceInterface = (*wrapSourcesV1alpha1AzureBlobStorageSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AzureBlobStorageSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AzureBlobStorageSource, opts v1.CreateOptions) (*sourcesv1alpha1.AzureBlobStorageSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureBlobStorageSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureBlobStorageSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureBlobStorageSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AzureBlobStorageSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AzureBlobStorageSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AzureBlobStorageSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureBlobStorageSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureBlobStorageSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AzureBlobStorageSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureBlobStorageSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureBlobStorageSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AzureBlobStorageSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureBlobStorageSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureBlobStorageSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AzureBlobStorageSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureBlobStorageSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureBlobStorageSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureBlobStorageSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureBlobStorageSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AzureBlobStorageSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureBlobStorageSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureBlobStorageSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureBlobStorageSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureBlobStorageSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AzureEventGridSources(namespace string) typedsourcesv1alpha1.AzureEventGridSourceInterface {
	return &wrapSourcesV1alpha1AzureEventGridSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "azureeventgridsources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AzureEventGridSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AzureEventGridSourceInterface = (*wrapSourcesV1alpha1AzureEventGridSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AzureEventGridSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AzureEventGridSource, opts v1.CreateOptions) (*sourcesv1alpha1.AzureEventGridSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureEventGridSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureEventGridSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureEventGridSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AzureEventGridSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AzureEventGridSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AzureEventGridSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureEventGridSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureEventGridSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AzureEventGridSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureEventGridSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureEventGridSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AzureEventGridSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureEventGridSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureEventGridSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AzureEventGridSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureEventGridSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureEventGridSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureEventGridSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureEventGridSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AzureEventGridSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureEventGridSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureEventGridSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureEventGridSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureEventGridSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AzureEventHubSources(namespace string) typedsourcesv1alpha1.AzureEventHubSourceInterface {
	return &wrapSourcesV1alpha1AzureEventHubSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "azureeventhubsources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AzureEventHubSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AzureEventHubSourceInterface = (*wrapSourcesV1alpha1AzureEventHubSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AzureEventHubSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AzureEventHubSource, opts v1.CreateOptions) (*sourcesv1alpha1.AzureEventHubSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureEventHubSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureEventHubSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureEventHubSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AzureEventHubSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AzureEventHubSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AzureEventHubSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureEventHubSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureEventHubSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AzureEventHubSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureEventHubSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureEventHubSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AzureEventHubSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureEventHubSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureEventHubSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AzureEventHubSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureEventHubSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureEventHubSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureEventHubSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureEventHubSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AzureEventHubSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureEventHubSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureEventHubSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureEventHubSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureEventHubSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AzureIOTHubSources(namespace string) typedsourcesv1alpha1.AzureIOTHubSourceInterface {
	return &wrapSourcesV1alpha1AzureIOTHubSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "azureiothubsources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AzureIOTHubSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AzureIOTHubSourceInterface = (*wrapSourcesV1alpha1AzureIOTHubSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AzureIOTHubSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AzureIOTHubSource, opts v1.CreateOptions) (*sourcesv1alpha1.AzureIOTHubSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureIOTHubSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureIOTHubSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureIOTHubSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AzureIOTHubSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AzureIOTHubSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AzureIOTHubSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureIOTHubSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureIOTHubSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AzureIOTHubSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureIOTHubSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureIOTHubSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AzureIOTHubSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureIOTHubSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureIOTHubSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AzureIOTHubSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureIOTHubSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureIOTHubSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureIOTHubSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureIOTHubSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AzureIOTHubSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureIOTHubSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureIOTHubSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureIOTHubSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureIOTHubSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AzureQueueStorageSources(namespace string) typedsourcesv1alpha1.AzureQueueStorageSourceInterface {
	return &wrapSourcesV1alpha1AzureQueueStorageSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "azurequeuestoragesources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AzureQueueStorageSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AzureQueueStorageSourceInterface = (*wrapSourcesV1alpha1AzureQueueStorageSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AzureQueueStorageSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AzureQueueStorageSource, opts v1.CreateOptions) (*sourcesv1alpha1.AzureQueueStorageSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureQueueStorageSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureQueueStorageSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureQueueStorageSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AzureQueueStorageSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AzureQueueStorageSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AzureQueueStorageSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureQueueStorageSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureQueueStorageSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AzureQueueStorageSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureQueueStorageSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureQueueStorageSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AzureQueueStorageSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureQueueStorageSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureQueueStorageSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AzureQueueStorageSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureQueueStorageSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureQueueStorageSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureQueueStorageSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureQueueStorageSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AzureQueueStorageSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureQueueStorageSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureQueueStorageSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureQueueStorageSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureQueueStorageSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AzureServiceBusQueueSources(namespace string) typedsourcesv1alpha1.AzureServiceBusQueueSourceInterface {
	return &wrapSourcesV1alpha1AzureServiceBusQueueSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "azureservicebusqueuesources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AzureServiceBusQueueSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AzureServiceBusQueueSourceInterface = (*wrapSourcesV1alpha1AzureServiceBusQueueSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AzureServiceBusQueueSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AzureServiceBusQueueSource, opts v1.CreateOptions) (*sourcesv1alpha1.AzureServiceBusQueueSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureServiceBusQueueSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureServiceBusQueueSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureServiceBusQueueSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AzureServiceBusQueueSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AzureServiceBusQueueSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AzureServiceBusQueueSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureServiceBusQueueSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureServiceBusQueueSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AzureServiceBusQueueSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureServiceBusQueueSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureServiceBusQueueSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AzureServiceBusQueueSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureServiceBusQueueSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureServiceBusQueueSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AzureServiceBusQueueSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureServiceBusQueueSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureServiceBusQueueSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureServiceBusQueueSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureServiceBusQueueSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AzureServiceBusQueueSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureServiceBusQueueSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureServiceBusQueueSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureServiceBusQueueSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureServiceBusQueueSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) AzureServiceBusTopicSources(namespace string) typedsourcesv1alpha1.AzureServiceBusTopicSourceInterface {
	return &wrapSourcesV1alpha1AzureServiceBusTopicSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "azureservicebustopicsources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1AzureServiceBusTopicSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.AzureServiceBusTopicSourceInterface = (*wrapSourcesV1alpha1AzureServiceBusTopicSourceImpl)(nil)

func (w *wrapSourcesV1alpha1AzureServiceBusTopicSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.AzureServiceBusTopicSource, opts v1.CreateOptions) (*sourcesv1alpha1.AzureServiceBusTopicSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureServiceBusTopicSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureServiceBusTopicSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureServiceBusTopicSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1AzureServiceBusTopicSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1AzureServiceBusTopicSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.AzureServiceBusTopicSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureServiceBusTopicSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureServiceBusTopicSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.AzureServiceBusTopicSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureServiceBusTopicSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureServiceBusTopicSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.AzureServiceBusTopicSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureServiceBusTopicSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureServiceBusTopicSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.AzureServiceBusTopicSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureServiceBusTopicSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureServiceBusTopicSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureServiceBusTopicSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureServiceBusTopicSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.AzureServiceBusTopicSource, opts v1.UpdateOptions) (*sourcesv1alpha1.AzureServiceBusTopicSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureServiceBusTopicSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.AzureServiceBusTopicSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1AzureServiceBusTopicSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) GoogleCloudAuditLogsSources(namespace string) typedsourcesv1alpha1.GoogleCloudAuditLogsSourceInterface {
	return &wrapSourcesV1alpha1GoogleCloudAuditLogsSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "googlecloudauditlogssources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1GoogleCloudAuditLogsSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.GoogleCloudAuditLogsSourceInterface = (*wrapSourcesV1alpha1GoogleCloudAuditLogsSourceImpl)(nil)

func (w *wrapSourcesV1alpha1GoogleCloudAuditLogsSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.GoogleCloudAuditLogsSource, opts v1.CreateOptions) (*sourcesv1alpha1.GoogleCloudAuditLogsSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudAuditLogsSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudAuditLogsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudAuditLogsSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1GoogleCloudAuditLogsSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1GoogleCloudAuditLogsSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.GoogleCloudAuditLogsSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudAuditLogsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudAuditLogsSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.GoogleCloudAuditLogsSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudAuditLogsSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudAuditLogsSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.GoogleCloudAuditLogsSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudAuditLogsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudAuditLogsSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.GoogleCloudAuditLogsSource, opts v1.UpdateOptions) (*sourcesv1alpha1.GoogleCloudAuditLogsSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudAuditLogsSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudAuditLogsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudAuditLogsSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.GoogleCloudAuditLogsSource, opts v1.UpdateOptions) (*sourcesv1alpha1.GoogleCloudAuditLogsSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudAuditLogsSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudAuditLogsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudAuditLogsSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) GoogleCloudBillingSources(namespace string) typedsourcesv1alpha1.GoogleCloudBillingSourceInterface {
	return &wrapSourcesV1alpha1GoogleCloudBillingSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "googlecloudbillingsources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1GoogleCloudBillingSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.GoogleCloudBillingSourceInterface = (*wrapSourcesV1alpha1GoogleCloudBillingSourceImpl)(nil)

func (w *wrapSourcesV1alpha1GoogleCloudBillingSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.GoogleCloudBillingSource, opts v1.CreateOptions) (*sourcesv1alpha1.GoogleCloudBillingSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudBillingSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudBillingSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudBillingSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1GoogleCloudBillingSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1GoogleCloudBillingSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.GoogleCloudBillingSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudBillingSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudBillingSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.GoogleCloudBillingSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudBillingSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudBillingSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.GoogleCloudBillingSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudBillingSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudBillingSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.GoogleCloudBillingSource, opts v1.UpdateOptions) (*sourcesv1alpha1.GoogleCloudBillingSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudBillingSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudBillingSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudBillingSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.GoogleCloudBillingSource, opts v1.UpdateOptions) (*sourcesv1alpha1.GoogleCloudBillingSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudBillingSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudBillingSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudBillingSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) GoogleCloudIoTSources(namespace string) typedsourcesv1alpha1.GoogleCloudIoTSourceInterface {
	return &wrapSourcesV1alpha1GoogleCloudIoTSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "googlecloudiotsources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1GoogleCloudIoTSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.GoogleCloudIoTSourceInterface = (*wrapSourcesV1alpha1GoogleCloudIoTSourceImpl)(nil)

func (w *wrapSourcesV1alpha1GoogleCloudIoTSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.GoogleCloudIoTSource, opts v1.CreateOptions) (*sourcesv1alpha1.GoogleCloudIoTSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudIoTSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudIoTSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudIoTSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1GoogleCloudIoTSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1GoogleCloudIoTSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.GoogleCloudIoTSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudIoTSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudIoTSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.GoogleCloudIoTSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudIoTSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudIoTSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.GoogleCloudIoTSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudIoTSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudIoTSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.GoogleCloudIoTSource, opts v1.UpdateOptions) (*sourcesv1alpha1.GoogleCloudIoTSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudIoTSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudIoTSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudIoTSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.GoogleCloudIoTSource, opts v1.UpdateOptions) (*sourcesv1alpha1.GoogleCloudIoTSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudIoTSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudIoTSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudIoTSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) GoogleCloudPubSubSources(namespace string) typedsourcesv1alpha1.GoogleCloudPubSubSourceInterface {
	return &wrapSourcesV1alpha1GoogleCloudPubSubSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "googlecloudpubsubsources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1GoogleCloudPubSubSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.GoogleCloudPubSubSourceInterface = (*wrapSourcesV1alpha1GoogleCloudPubSubSourceImpl)(nil)

func (w *wrapSourcesV1alpha1GoogleCloudPubSubSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.GoogleCloudPubSubSource, opts v1.CreateOptions) (*sourcesv1alpha1.GoogleCloudPubSubSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudPubSubSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudPubSubSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudPubSubSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1GoogleCloudPubSubSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1GoogleCloudPubSubSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.GoogleCloudPubSubSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudPubSubSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudPubSubSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.GoogleCloudPubSubSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudPubSubSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudPubSubSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.GoogleCloudPubSubSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudPubSubSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudPubSubSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.GoogleCloudPubSubSource, opts v1.UpdateOptions) (*sourcesv1alpha1.GoogleCloudPubSubSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudPubSubSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudPubSubSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudPubSubSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.GoogleCloudPubSubSource, opts v1.UpdateOptions) (*sourcesv1alpha1.GoogleCloudPubSubSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudPubSubSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudPubSubSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudPubSubSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) GoogleCloudSourceRepositoriesSources(namespace string) typedsourcesv1alpha1.GoogleCloudSourceRepositoriesSourceInterface {
	return &wrapSourcesV1alpha1GoogleCloudSourceRepositoriesSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "googlecloudsourcerepositoriessources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1GoogleCloudSourceRepositoriesSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.GoogleCloudSourceRepositoriesSourceInterface = (*wrapSourcesV1alpha1GoogleCloudSourceRepositoriesSourceImpl)(nil)

func (w *wrapSourcesV1alpha1GoogleCloudSourceRepositoriesSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.GoogleCloudSourceRepositoriesSource, opts v1.CreateOptions) (*sourcesv1alpha1.GoogleCloudSourceRepositoriesSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudSourceRepositoriesSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudSourceRepositoriesSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudSourceRepositoriesSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1GoogleCloudSourceRepositoriesSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1GoogleCloudSourceRepositoriesSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.GoogleCloudSourceRepositoriesSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudSourceRepositoriesSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudSourceRepositoriesSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.GoogleCloudSourceRepositoriesSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudSourceRepositoriesSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudSourceRepositoriesSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.GoogleCloudSourceRepositoriesSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudSourceRepositoriesSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudSourceRepositoriesSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.GoogleCloudSourceRepositoriesSource, opts v1.UpdateOptions) (*sourcesv1alpha1.GoogleCloudSourceRepositoriesSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudSourceRepositoriesSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudSourceRepositoriesSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudSourceRepositoriesSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.GoogleCloudSourceRepositoriesSource, opts v1.UpdateOptions) (*sourcesv1alpha1.GoogleCloudSourceRepositoriesSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudSourceRepositoriesSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudSourceRepositoriesSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudSourceRepositoriesSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) GoogleCloudStorageSources(namespace string) typedsourcesv1alpha1.GoogleCloudStorageSourceInterface {
	return &wrapSourcesV1alpha1GoogleCloudStorageSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "googlecloudstoragesources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1GoogleCloudStorageSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.GoogleCloudStorageSourceInterface = (*wrapSourcesV1alpha1GoogleCloudStorageSourceImpl)(nil)

func (w *wrapSourcesV1alpha1GoogleCloudStorageSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.GoogleCloudStorageSource, opts v1.CreateOptions) (*sourcesv1alpha1.GoogleCloudStorageSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudStorageSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudStorageSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudStorageSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1GoogleCloudStorageSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1GoogleCloudStorageSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.GoogleCloudStorageSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudStorageSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudStorageSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.GoogleCloudStorageSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudStorageSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudStorageSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.GoogleCloudStorageSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudStorageSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudStorageSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.GoogleCloudStorageSource, opts v1.UpdateOptions) (*sourcesv1alpha1.GoogleCloudStorageSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudStorageSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudStorageSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudStorageSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.GoogleCloudStorageSource, opts v1.UpdateOptions) (*sourcesv1alpha1.GoogleCloudStorageSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudStorageSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.GoogleCloudStorageSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1GoogleCloudStorageSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) HTTPPollerSources(namespace string) typedsourcesv1alpha1.HTTPPollerSourceInterface {
	return &wrapSourcesV1alpha1HTTPPollerSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "httppollersources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1HTTPPollerSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.HTTPPollerSourceInterface = (*wrapSourcesV1alpha1HTTPPollerSourceImpl)(nil)

func (w *wrapSourcesV1alpha1HTTPPollerSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.HTTPPollerSource, opts v1.CreateOptions) (*sourcesv1alpha1.HTTPPollerSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "HTTPPollerSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.HTTPPollerSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1HTTPPollerSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1HTTPPollerSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1HTTPPollerSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.HTTPPollerSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.HTTPPollerSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1HTTPPollerSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.HTTPPollerSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.HTTPPollerSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1HTTPPollerSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.HTTPPollerSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.HTTPPollerSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1HTTPPollerSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.HTTPPollerSource, opts v1.UpdateOptions) (*sourcesv1alpha1.HTTPPollerSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "HTTPPollerSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.HTTPPollerSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1HTTPPollerSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.HTTPPollerSource, opts v1.UpdateOptions) (*sourcesv1alpha1.HTTPPollerSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "HTTPPollerSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.HTTPPollerSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1HTTPPollerSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) IBMMQSources(namespace string) typedsourcesv1alpha1.IBMMQSourceInterface {
	return &wrapSourcesV1alpha1IBMMQSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "ibmmqsources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1IBMMQSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.IBMMQSourceInterface = (*wrapSourcesV1alpha1IBMMQSourceImpl)(nil)

func (w *wrapSourcesV1alpha1IBMMQSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.IBMMQSource, opts v1.CreateOptions) (*sourcesv1alpha1.IBMMQSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "IBMMQSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.IBMMQSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1IBMMQSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1IBMMQSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1IBMMQSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.IBMMQSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.IBMMQSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1IBMMQSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.IBMMQSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.IBMMQSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1IBMMQSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.IBMMQSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.IBMMQSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1IBMMQSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.IBMMQSource, opts v1.UpdateOptions) (*sourcesv1alpha1.IBMMQSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "IBMMQSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.IBMMQSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1IBMMQSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.IBMMQSource, opts v1.UpdateOptions) (*sourcesv1alpha1.IBMMQSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "IBMMQSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.IBMMQSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1IBMMQSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) OCIMetricsSources(namespace string) typedsourcesv1alpha1.OCIMetricsSourceInterface {
	return &wrapSourcesV1alpha1OCIMetricsSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "ocimetricssources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1OCIMetricsSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.OCIMetricsSourceInterface = (*wrapSourcesV1alpha1OCIMetricsSourceImpl)(nil)

func (w *wrapSourcesV1alpha1OCIMetricsSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.OCIMetricsSource, opts v1.CreateOptions) (*sourcesv1alpha1.OCIMetricsSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "OCIMetricsSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.OCIMetricsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1OCIMetricsSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1OCIMetricsSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1OCIMetricsSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.OCIMetricsSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.OCIMetricsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1OCIMetricsSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.OCIMetricsSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.OCIMetricsSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1OCIMetricsSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.OCIMetricsSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.OCIMetricsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1OCIMetricsSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.OCIMetricsSource, opts v1.UpdateOptions) (*sourcesv1alpha1.OCIMetricsSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "OCIMetricsSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.OCIMetricsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1OCIMetricsSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.OCIMetricsSource, opts v1.UpdateOptions) (*sourcesv1alpha1.OCIMetricsSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "OCIMetricsSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.OCIMetricsSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1OCIMetricsSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) SalesforceSources(namespace string) typedsourcesv1alpha1.SalesforceSourceInterface {
	return &wrapSourcesV1alpha1SalesforceSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "salesforcesources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1SalesforceSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.SalesforceSourceInterface = (*wrapSourcesV1alpha1SalesforceSourceImpl)(nil)

func (w *wrapSourcesV1alpha1SalesforceSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.SalesforceSource, opts v1.CreateOptions) (*sourcesv1alpha1.SalesforceSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SalesforceSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.SalesforceSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1SalesforceSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1SalesforceSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1SalesforceSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.SalesforceSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.SalesforceSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1SalesforceSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.SalesforceSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.SalesforceSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1SalesforceSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.SalesforceSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.SalesforceSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1SalesforceSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.SalesforceSource, opts v1.UpdateOptions) (*sourcesv1alpha1.SalesforceSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SalesforceSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.SalesforceSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1SalesforceSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.SalesforceSource, opts v1.UpdateOptions) (*sourcesv1alpha1.SalesforceSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SalesforceSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.SalesforceSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1SalesforceSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) SlackSources(namespace string) typedsourcesv1alpha1.SlackSourceInterface {
	return &wrapSourcesV1alpha1SlackSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "slacksources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1SlackSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.SlackSourceInterface = (*wrapSourcesV1alpha1SlackSourceImpl)(nil)

func (w *wrapSourcesV1alpha1SlackSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.SlackSource, opts v1.CreateOptions) (*sourcesv1alpha1.SlackSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SlackSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.SlackSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1SlackSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1SlackSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1SlackSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.SlackSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.SlackSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1SlackSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.SlackSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.SlackSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1SlackSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.SlackSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.SlackSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1SlackSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.SlackSource, opts v1.UpdateOptions) (*sourcesv1alpha1.SlackSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SlackSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.SlackSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1SlackSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.SlackSource, opts v1.UpdateOptions) (*sourcesv1alpha1.SlackSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SlackSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.SlackSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1SlackSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) TwilioSources(namespace string) typedsourcesv1alpha1.TwilioSourceInterface {
	return &wrapSourcesV1alpha1TwilioSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "twiliosources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1TwilioSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.TwilioSourceInterface = (*wrapSourcesV1alpha1TwilioSourceImpl)(nil)

func (w *wrapSourcesV1alpha1TwilioSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.TwilioSource, opts v1.CreateOptions) (*sourcesv1alpha1.TwilioSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "TwilioSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.TwilioSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1TwilioSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1TwilioSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1TwilioSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.TwilioSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.TwilioSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1TwilioSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.TwilioSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.TwilioSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1TwilioSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.TwilioSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.TwilioSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1TwilioSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.TwilioSource, opts v1.UpdateOptions) (*sourcesv1alpha1.TwilioSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "TwilioSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.TwilioSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1TwilioSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.TwilioSource, opts v1.UpdateOptions) (*sourcesv1alpha1.TwilioSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "TwilioSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.TwilioSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1TwilioSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) WebhookSources(namespace string) typedsourcesv1alpha1.WebhookSourceInterface {
	return &wrapSourcesV1alpha1WebhookSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "webhooksources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1WebhookSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.WebhookSourceInterface = (*wrapSourcesV1alpha1WebhookSourceImpl)(nil)

func (w *wrapSourcesV1alpha1WebhookSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.WebhookSource, opts v1.CreateOptions) (*sourcesv1alpha1.WebhookSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "WebhookSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.WebhookSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1WebhookSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1WebhookSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1WebhookSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.WebhookSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.WebhookSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1WebhookSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.WebhookSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.WebhookSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1WebhookSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.WebhookSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.WebhookSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1WebhookSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.WebhookSource, opts v1.UpdateOptions) (*sourcesv1alpha1.WebhookSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "WebhookSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.WebhookSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1WebhookSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.WebhookSource, opts v1.UpdateOptions) (*sourcesv1alpha1.WebhookSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "WebhookSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.WebhookSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1WebhookSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapSourcesV1alpha1) ZendeskSources(namespace string) typedsourcesv1alpha1.ZendeskSourceInterface {
	return &wrapSourcesV1alpha1ZendeskSourceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "sources.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "zendesksources",
		}),

		namespace: namespace,
	}
}

type wrapSourcesV1alpha1ZendeskSourceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedsourcesv1alpha1.ZendeskSourceInterface = (*wrapSourcesV1alpha1ZendeskSourceImpl)(nil)

func (w *wrapSourcesV1alpha1ZendeskSourceImpl) Create(ctx context.Context, in *sourcesv1alpha1.ZendeskSource, opts v1.CreateOptions) (*sourcesv1alpha1.ZendeskSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "ZendeskSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.ZendeskSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1ZendeskSourceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapSourcesV1alpha1ZendeskSourceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapSourcesV1alpha1ZendeskSourceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*sourcesv1alpha1.ZendeskSource, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.ZendeskSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1ZendeskSourceImpl) List(ctx context.Context, opts v1.ListOptions) (*sourcesv1alpha1.ZendeskSourceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.ZendeskSourceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1ZendeskSourceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *sourcesv1alpha1.ZendeskSource, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.ZendeskSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1ZendeskSourceImpl) Update(ctx context.Context, in *sourcesv1alpha1.ZendeskSource, opts v1.UpdateOptions) (*sourcesv1alpha1.ZendeskSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "ZendeskSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.ZendeskSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1ZendeskSourceImpl) UpdateStatus(ctx context.Context, in *sourcesv1alpha1.ZendeskSource, opts v1.UpdateOptions) (*sourcesv1alpha1.ZendeskSource, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "sources.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "ZendeskSource",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &sourcesv1alpha1.ZendeskSource{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapSourcesV1alpha1ZendeskSourceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

// TargetsV1alpha1 retrieves the TargetsV1alpha1Client
func (w *wrapClient) TargetsV1alpha1() typedtargetsv1alpha1.TargetsV1alpha1Interface {
	return &wrapTargetsV1alpha1{
		dyn: w.dyn,
	}
}

type wrapTargetsV1alpha1 struct {
	dyn dynamic.Interface
}

func (w *wrapTargetsV1alpha1) RESTClient() rest.Interface {
	panic("RESTClient called on dynamic client!")
}

func (w *wrapTargetsV1alpha1) AWSComprehendTargets(namespace string) typedtargetsv1alpha1.AWSComprehendTargetInterface {
	return &wrapTargetsV1alpha1AWSComprehendTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awscomprehendtargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1AWSComprehendTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.AWSComprehendTargetInterface = (*wrapTargetsV1alpha1AWSComprehendTargetImpl)(nil)

func (w *wrapTargetsV1alpha1AWSComprehendTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.AWSComprehendTarget, opts v1.CreateOptions) (*targetsv1alpha1.AWSComprehendTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSComprehendTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSComprehendTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSComprehendTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1AWSComprehendTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1AWSComprehendTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.AWSComprehendTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSComprehendTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSComprehendTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.AWSComprehendTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSComprehendTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSComprehendTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.AWSComprehendTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSComprehendTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSComprehendTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.AWSComprehendTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AWSComprehendTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSComprehendTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSComprehendTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSComprehendTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.AWSComprehendTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AWSComprehendTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSComprehendTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSComprehendTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSComprehendTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) AWSDynamoDBTargets(namespace string) typedtargetsv1alpha1.AWSDynamoDBTargetInterface {
	return &wrapTargetsV1alpha1AWSDynamoDBTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awsdynamodbtargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1AWSDynamoDBTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.AWSDynamoDBTargetInterface = (*wrapTargetsV1alpha1AWSDynamoDBTargetImpl)(nil)

func (w *wrapTargetsV1alpha1AWSDynamoDBTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.AWSDynamoDBTarget, opts v1.CreateOptions) (*targetsv1alpha1.AWSDynamoDBTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSDynamoDBTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSDynamoDBTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSDynamoDBTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1AWSDynamoDBTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1AWSDynamoDBTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.AWSDynamoDBTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSDynamoDBTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSDynamoDBTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.AWSDynamoDBTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSDynamoDBTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSDynamoDBTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.AWSDynamoDBTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSDynamoDBTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSDynamoDBTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.AWSDynamoDBTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AWSDynamoDBTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSDynamoDBTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSDynamoDBTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSDynamoDBTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.AWSDynamoDBTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AWSDynamoDBTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSDynamoDBTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSDynamoDBTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSDynamoDBTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) AWSKinesisTargets(namespace string) typedtargetsv1alpha1.AWSKinesisTargetInterface {
	return &wrapTargetsV1alpha1AWSKinesisTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awskinesistargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1AWSKinesisTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.AWSKinesisTargetInterface = (*wrapTargetsV1alpha1AWSKinesisTargetImpl)(nil)

func (w *wrapTargetsV1alpha1AWSKinesisTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.AWSKinesisTarget, opts v1.CreateOptions) (*targetsv1alpha1.AWSKinesisTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSKinesisTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSKinesisTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSKinesisTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1AWSKinesisTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1AWSKinesisTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.AWSKinesisTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSKinesisTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSKinesisTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.AWSKinesisTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSKinesisTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSKinesisTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.AWSKinesisTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSKinesisTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSKinesisTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.AWSKinesisTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AWSKinesisTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSKinesisTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSKinesisTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSKinesisTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.AWSKinesisTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AWSKinesisTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSKinesisTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSKinesisTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSKinesisTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) AWSLambdaTargets(namespace string) typedtargetsv1alpha1.AWSLambdaTargetInterface {
	return &wrapTargetsV1alpha1AWSLambdaTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awslambdatargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1AWSLambdaTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.AWSLambdaTargetInterface = (*wrapTargetsV1alpha1AWSLambdaTargetImpl)(nil)

func (w *wrapTargetsV1alpha1AWSLambdaTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.AWSLambdaTarget, opts v1.CreateOptions) (*targetsv1alpha1.AWSLambdaTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSLambdaTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSLambdaTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSLambdaTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1AWSLambdaTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1AWSLambdaTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.AWSLambdaTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSLambdaTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSLambdaTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.AWSLambdaTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSLambdaTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSLambdaTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.AWSLambdaTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSLambdaTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSLambdaTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.AWSLambdaTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AWSLambdaTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSLambdaTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSLambdaTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSLambdaTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.AWSLambdaTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AWSLambdaTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSLambdaTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSLambdaTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSLambdaTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) AWSS3Targets(namespace string) typedtargetsv1alpha1.AWSS3TargetInterface {
	return &wrapTargetsV1alpha1AWSS3TargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awss3targets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1AWSS3TargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.AWSS3TargetInterface = (*wrapTargetsV1alpha1AWSS3TargetImpl)(nil)

func (w *wrapTargetsV1alpha1AWSS3TargetImpl) Create(ctx context.Context, in *targetsv1alpha1.AWSS3Target, opts v1.CreateOptions) (*targetsv1alpha1.AWSS3Target, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSS3Target",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSS3Target{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSS3TargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1AWSS3TargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1AWSS3TargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.AWSS3Target, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSS3Target{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSS3TargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.AWSS3TargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSS3TargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSS3TargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.AWSS3Target, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSS3Target{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSS3TargetImpl) Update(ctx context.Context, in *targetsv1alpha1.AWSS3Target, opts v1.UpdateOptions) (*targetsv1alpha1.AWSS3Target, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSS3Target",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSS3Target{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSS3TargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.AWSS3Target, opts v1.UpdateOptions) (*targetsv1alpha1.AWSS3Target, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSS3Target",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSS3Target{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSS3TargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) AWSSNSTargets(namespace string) typedtargetsv1alpha1.AWSSNSTargetInterface {
	return &wrapTargetsV1alpha1AWSSNSTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awssnstargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1AWSSNSTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.AWSSNSTargetInterface = (*wrapTargetsV1alpha1AWSSNSTargetImpl)(nil)

func (w *wrapTargetsV1alpha1AWSSNSTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.AWSSNSTarget, opts v1.CreateOptions) (*targetsv1alpha1.AWSSNSTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSSNSTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSSNSTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSSNSTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1AWSSNSTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1AWSSNSTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.AWSSNSTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSSNSTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSSNSTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.AWSSNSTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSSNSTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSSNSTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.AWSSNSTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSSNSTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSSNSTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.AWSSNSTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AWSSNSTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSSNSTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSSNSTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSSNSTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.AWSSNSTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AWSSNSTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSSNSTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSSNSTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSSNSTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) AWSSQSTargets(namespace string) typedtargetsv1alpha1.AWSSQSTargetInterface {
	return &wrapTargetsV1alpha1AWSSQSTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "awssqstargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1AWSSQSTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.AWSSQSTargetInterface = (*wrapTargetsV1alpha1AWSSQSTargetImpl)(nil)

func (w *wrapTargetsV1alpha1AWSSQSTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.AWSSQSTarget, opts v1.CreateOptions) (*targetsv1alpha1.AWSSQSTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSSQSTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSSQSTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSSQSTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1AWSSQSTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1AWSSQSTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.AWSSQSTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSSQSTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSSQSTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.AWSSQSTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSSQSTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSSQSTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.AWSSQSTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSSQSTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSSQSTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.AWSSQSTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AWSSQSTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSSQSTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSSQSTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSSQSTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.AWSSQSTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AWSSQSTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AWSSQSTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AWSSQSTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AWSSQSTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) AlibabaOSSTargets(namespace string) typedtargetsv1alpha1.AlibabaOSSTargetInterface {
	return &wrapTargetsV1alpha1AlibabaOSSTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "alibabaosstargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1AlibabaOSSTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.AlibabaOSSTargetInterface = (*wrapTargetsV1alpha1AlibabaOSSTargetImpl)(nil)

func (w *wrapTargetsV1alpha1AlibabaOSSTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.AlibabaOSSTarget, opts v1.CreateOptions) (*targetsv1alpha1.AlibabaOSSTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AlibabaOSSTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AlibabaOSSTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AlibabaOSSTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1AlibabaOSSTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1AlibabaOSSTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.AlibabaOSSTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AlibabaOSSTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AlibabaOSSTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.AlibabaOSSTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AlibabaOSSTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AlibabaOSSTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.AlibabaOSSTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AlibabaOSSTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AlibabaOSSTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.AlibabaOSSTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AlibabaOSSTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AlibabaOSSTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AlibabaOSSTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AlibabaOSSTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.AlibabaOSSTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AlibabaOSSTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AlibabaOSSTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AlibabaOSSTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AlibabaOSSTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) AzureEventHubsTargets(namespace string) typedtargetsv1alpha1.AzureEventHubsTargetInterface {
	return &wrapTargetsV1alpha1AzureEventHubsTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "azureeventhubstargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1AzureEventHubsTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.AzureEventHubsTargetInterface = (*wrapTargetsV1alpha1AzureEventHubsTargetImpl)(nil)

func (w *wrapTargetsV1alpha1AzureEventHubsTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.AzureEventHubsTarget, opts v1.CreateOptions) (*targetsv1alpha1.AzureEventHubsTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureEventHubsTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AzureEventHubsTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AzureEventHubsTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1AzureEventHubsTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1AzureEventHubsTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.AzureEventHubsTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AzureEventHubsTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AzureEventHubsTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.AzureEventHubsTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AzureEventHubsTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AzureEventHubsTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.AzureEventHubsTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AzureEventHubsTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AzureEventHubsTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.AzureEventHubsTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AzureEventHubsTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureEventHubsTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AzureEventHubsTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AzureEventHubsTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.AzureEventHubsTarget, opts v1.UpdateOptions) (*targetsv1alpha1.AzureEventHubsTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "AzureEventHubsTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.AzureEventHubsTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1AzureEventHubsTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) ConfluentTargets(namespace string) typedtargetsv1alpha1.ConfluentTargetInterface {
	return &wrapTargetsV1alpha1ConfluentTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "confluenttargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1ConfluentTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.ConfluentTargetInterface = (*wrapTargetsV1alpha1ConfluentTargetImpl)(nil)

func (w *wrapTargetsV1alpha1ConfluentTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.ConfluentTarget, opts v1.CreateOptions) (*targetsv1alpha1.ConfluentTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "ConfluentTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ConfluentTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ConfluentTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1ConfluentTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1ConfluentTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.ConfluentTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ConfluentTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ConfluentTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.ConfluentTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ConfluentTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ConfluentTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.ConfluentTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ConfluentTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ConfluentTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.ConfluentTarget, opts v1.UpdateOptions) (*targetsv1alpha1.ConfluentTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "ConfluentTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ConfluentTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ConfluentTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.ConfluentTarget, opts v1.UpdateOptions) (*targetsv1alpha1.ConfluentTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "ConfluentTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ConfluentTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ConfluentTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) DatadogTargets(namespace string) typedtargetsv1alpha1.DatadogTargetInterface {
	return &wrapTargetsV1alpha1DatadogTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "datadogtargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1DatadogTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.DatadogTargetInterface = (*wrapTargetsV1alpha1DatadogTargetImpl)(nil)

func (w *wrapTargetsV1alpha1DatadogTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.DatadogTarget, opts v1.CreateOptions) (*targetsv1alpha1.DatadogTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "DatadogTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.DatadogTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1DatadogTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1DatadogTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1DatadogTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.DatadogTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.DatadogTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1DatadogTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.DatadogTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.DatadogTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1DatadogTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.DatadogTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.DatadogTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1DatadogTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.DatadogTarget, opts v1.UpdateOptions) (*targetsv1alpha1.DatadogTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "DatadogTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.DatadogTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1DatadogTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.DatadogTarget, opts v1.UpdateOptions) (*targetsv1alpha1.DatadogTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "DatadogTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.DatadogTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1DatadogTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) ElasticsearchTargets(namespace string) typedtargetsv1alpha1.ElasticsearchTargetInterface {
	return &wrapTargetsV1alpha1ElasticsearchTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "elasticsearchtargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1ElasticsearchTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.ElasticsearchTargetInterface = (*wrapTargetsV1alpha1ElasticsearchTargetImpl)(nil)

func (w *wrapTargetsV1alpha1ElasticsearchTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.ElasticsearchTarget, opts v1.CreateOptions) (*targetsv1alpha1.ElasticsearchTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "ElasticsearchTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ElasticsearchTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ElasticsearchTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1ElasticsearchTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1ElasticsearchTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.ElasticsearchTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ElasticsearchTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ElasticsearchTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.ElasticsearchTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ElasticsearchTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ElasticsearchTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.ElasticsearchTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ElasticsearchTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ElasticsearchTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.ElasticsearchTarget, opts v1.UpdateOptions) (*targetsv1alpha1.ElasticsearchTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "ElasticsearchTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ElasticsearchTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ElasticsearchTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.ElasticsearchTarget, opts v1.UpdateOptions) (*targetsv1alpha1.ElasticsearchTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "ElasticsearchTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ElasticsearchTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ElasticsearchTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) GoogleCloudFirestoreTargets(namespace string) typedtargetsv1alpha1.GoogleCloudFirestoreTargetInterface {
	return &wrapTargetsV1alpha1GoogleCloudFirestoreTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "googlecloudfirestoretargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1GoogleCloudFirestoreTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.GoogleCloudFirestoreTargetInterface = (*wrapTargetsV1alpha1GoogleCloudFirestoreTargetImpl)(nil)

func (w *wrapTargetsV1alpha1GoogleCloudFirestoreTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.GoogleCloudFirestoreTarget, opts v1.CreateOptions) (*targetsv1alpha1.GoogleCloudFirestoreTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudFirestoreTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudFirestoreTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudFirestoreTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1GoogleCloudFirestoreTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1GoogleCloudFirestoreTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.GoogleCloudFirestoreTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudFirestoreTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudFirestoreTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.GoogleCloudFirestoreTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudFirestoreTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudFirestoreTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.GoogleCloudFirestoreTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudFirestoreTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudFirestoreTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.GoogleCloudFirestoreTarget, opts v1.UpdateOptions) (*targetsv1alpha1.GoogleCloudFirestoreTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudFirestoreTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudFirestoreTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudFirestoreTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.GoogleCloudFirestoreTarget, opts v1.UpdateOptions) (*targetsv1alpha1.GoogleCloudFirestoreTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudFirestoreTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudFirestoreTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudFirestoreTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) GoogleCloudStorageTargets(namespace string) typedtargetsv1alpha1.GoogleCloudStorageTargetInterface {
	return &wrapTargetsV1alpha1GoogleCloudStorageTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "googlecloudstoragetargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1GoogleCloudStorageTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.GoogleCloudStorageTargetInterface = (*wrapTargetsV1alpha1GoogleCloudStorageTargetImpl)(nil)

func (w *wrapTargetsV1alpha1GoogleCloudStorageTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.GoogleCloudStorageTarget, opts v1.CreateOptions) (*targetsv1alpha1.GoogleCloudStorageTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudStorageTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudStorageTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudStorageTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1GoogleCloudStorageTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1GoogleCloudStorageTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.GoogleCloudStorageTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudStorageTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudStorageTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.GoogleCloudStorageTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudStorageTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudStorageTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.GoogleCloudStorageTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudStorageTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudStorageTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.GoogleCloudStorageTarget, opts v1.UpdateOptions) (*targetsv1alpha1.GoogleCloudStorageTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudStorageTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudStorageTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudStorageTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.GoogleCloudStorageTarget, opts v1.UpdateOptions) (*targetsv1alpha1.GoogleCloudStorageTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudStorageTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudStorageTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudStorageTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) GoogleCloudWorkflowsTargets(namespace string) typedtargetsv1alpha1.GoogleCloudWorkflowsTargetInterface {
	return &wrapTargetsV1alpha1GoogleCloudWorkflowsTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "googlecloudworkflowstargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1GoogleCloudWorkflowsTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.GoogleCloudWorkflowsTargetInterface = (*wrapTargetsV1alpha1GoogleCloudWorkflowsTargetImpl)(nil)

func (w *wrapTargetsV1alpha1GoogleCloudWorkflowsTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.GoogleCloudWorkflowsTarget, opts v1.CreateOptions) (*targetsv1alpha1.GoogleCloudWorkflowsTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudWorkflowsTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudWorkflowsTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudWorkflowsTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1GoogleCloudWorkflowsTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1GoogleCloudWorkflowsTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.GoogleCloudWorkflowsTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudWorkflowsTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudWorkflowsTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.GoogleCloudWorkflowsTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudWorkflowsTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudWorkflowsTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.GoogleCloudWorkflowsTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudWorkflowsTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudWorkflowsTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.GoogleCloudWorkflowsTarget, opts v1.UpdateOptions) (*targetsv1alpha1.GoogleCloudWorkflowsTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudWorkflowsTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudWorkflowsTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudWorkflowsTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.GoogleCloudWorkflowsTarget, opts v1.UpdateOptions) (*targetsv1alpha1.GoogleCloudWorkflowsTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleCloudWorkflowsTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleCloudWorkflowsTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleCloudWorkflowsTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) GoogleSheetTargets(namespace string) typedtargetsv1alpha1.GoogleSheetTargetInterface {
	return &wrapTargetsV1alpha1GoogleSheetTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "googlesheettargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1GoogleSheetTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.GoogleSheetTargetInterface = (*wrapTargetsV1alpha1GoogleSheetTargetImpl)(nil)

func (w *wrapTargetsV1alpha1GoogleSheetTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.GoogleSheetTarget, opts v1.CreateOptions) (*targetsv1alpha1.GoogleSheetTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleSheetTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleSheetTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleSheetTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1GoogleSheetTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1GoogleSheetTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.GoogleSheetTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleSheetTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleSheetTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.GoogleSheetTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleSheetTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleSheetTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.GoogleSheetTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleSheetTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleSheetTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.GoogleSheetTarget, opts v1.UpdateOptions) (*targetsv1alpha1.GoogleSheetTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleSheetTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleSheetTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleSheetTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.GoogleSheetTarget, opts v1.UpdateOptions) (*targetsv1alpha1.GoogleSheetTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "GoogleSheetTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.GoogleSheetTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1GoogleSheetTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) HTTPTargets(namespace string) typedtargetsv1alpha1.HTTPTargetInterface {
	return &wrapTargetsV1alpha1HTTPTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "httptargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1HTTPTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.HTTPTargetInterface = (*wrapTargetsV1alpha1HTTPTargetImpl)(nil)

func (w *wrapTargetsV1alpha1HTTPTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.HTTPTarget, opts v1.CreateOptions) (*targetsv1alpha1.HTTPTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "HTTPTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.HTTPTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1HTTPTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1HTTPTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1HTTPTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.HTTPTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.HTTPTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1HTTPTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.HTTPTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.HTTPTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1HTTPTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.HTTPTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.HTTPTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1HTTPTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.HTTPTarget, opts v1.UpdateOptions) (*targetsv1alpha1.HTTPTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "HTTPTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.HTTPTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1HTTPTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.HTTPTarget, opts v1.UpdateOptions) (*targetsv1alpha1.HTTPTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "HTTPTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.HTTPTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1HTTPTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) HasuraTargets(namespace string) typedtargetsv1alpha1.HasuraTargetInterface {
	return &wrapTargetsV1alpha1HasuraTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "hasuratargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1HasuraTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.HasuraTargetInterface = (*wrapTargetsV1alpha1HasuraTargetImpl)(nil)

func (w *wrapTargetsV1alpha1HasuraTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.HasuraTarget, opts v1.CreateOptions) (*targetsv1alpha1.HasuraTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "HasuraTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.HasuraTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1HasuraTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1HasuraTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1HasuraTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.HasuraTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.HasuraTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1HasuraTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.HasuraTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.HasuraTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1HasuraTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.HasuraTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.HasuraTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1HasuraTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.HasuraTarget, opts v1.UpdateOptions) (*targetsv1alpha1.HasuraTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "HasuraTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.HasuraTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1HasuraTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.HasuraTarget, opts v1.UpdateOptions) (*targetsv1alpha1.HasuraTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "HasuraTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.HasuraTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1HasuraTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) IBMMQTargets(namespace string) typedtargetsv1alpha1.IBMMQTargetInterface {
	return &wrapTargetsV1alpha1IBMMQTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "ibmmqtargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1IBMMQTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.IBMMQTargetInterface = (*wrapTargetsV1alpha1IBMMQTargetImpl)(nil)

func (w *wrapTargetsV1alpha1IBMMQTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.IBMMQTarget, opts v1.CreateOptions) (*targetsv1alpha1.IBMMQTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "IBMMQTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.IBMMQTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1IBMMQTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1IBMMQTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1IBMMQTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.IBMMQTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.IBMMQTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1IBMMQTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.IBMMQTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.IBMMQTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1IBMMQTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.IBMMQTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.IBMMQTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1IBMMQTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.IBMMQTarget, opts v1.UpdateOptions) (*targetsv1alpha1.IBMMQTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "IBMMQTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.IBMMQTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1IBMMQTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.IBMMQTarget, opts v1.UpdateOptions) (*targetsv1alpha1.IBMMQTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "IBMMQTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.IBMMQTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1IBMMQTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) InfraTargets(namespace string) typedtargetsv1alpha1.InfraTargetInterface {
	return &wrapTargetsV1alpha1InfraTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "infratargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1InfraTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.InfraTargetInterface = (*wrapTargetsV1alpha1InfraTargetImpl)(nil)

func (w *wrapTargetsV1alpha1InfraTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.InfraTarget, opts v1.CreateOptions) (*targetsv1alpha1.InfraTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "InfraTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.InfraTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1InfraTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1InfraTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1InfraTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.InfraTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.InfraTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1InfraTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.InfraTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.InfraTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1InfraTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.InfraTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.InfraTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1InfraTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.InfraTarget, opts v1.UpdateOptions) (*targetsv1alpha1.InfraTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "InfraTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.InfraTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1InfraTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.InfraTarget, opts v1.UpdateOptions) (*targetsv1alpha1.InfraTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "InfraTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.InfraTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1InfraTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) JiraTargets(namespace string) typedtargetsv1alpha1.JiraTargetInterface {
	return &wrapTargetsV1alpha1JiraTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "jiratargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1JiraTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.JiraTargetInterface = (*wrapTargetsV1alpha1JiraTargetImpl)(nil)

func (w *wrapTargetsV1alpha1JiraTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.JiraTarget, opts v1.CreateOptions) (*targetsv1alpha1.JiraTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "JiraTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.JiraTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1JiraTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1JiraTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1JiraTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.JiraTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.JiraTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1JiraTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.JiraTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.JiraTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1JiraTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.JiraTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.JiraTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1JiraTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.JiraTarget, opts v1.UpdateOptions) (*targetsv1alpha1.JiraTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "JiraTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.JiraTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1JiraTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.JiraTarget, opts v1.UpdateOptions) (*targetsv1alpha1.JiraTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "JiraTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.JiraTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1JiraTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) LogzMetricsTargets(namespace string) typedtargetsv1alpha1.LogzMetricsTargetInterface {
	return &wrapTargetsV1alpha1LogzMetricsTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "logzmetricstargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1LogzMetricsTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.LogzMetricsTargetInterface = (*wrapTargetsV1alpha1LogzMetricsTargetImpl)(nil)

func (w *wrapTargetsV1alpha1LogzMetricsTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.LogzMetricsTarget, opts v1.CreateOptions) (*targetsv1alpha1.LogzMetricsTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "LogzMetricsTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.LogzMetricsTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1LogzMetricsTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1LogzMetricsTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1LogzMetricsTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.LogzMetricsTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.LogzMetricsTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1LogzMetricsTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.LogzMetricsTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.LogzMetricsTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1LogzMetricsTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.LogzMetricsTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.LogzMetricsTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1LogzMetricsTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.LogzMetricsTarget, opts v1.UpdateOptions) (*targetsv1alpha1.LogzMetricsTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "LogzMetricsTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.LogzMetricsTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1LogzMetricsTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.LogzMetricsTarget, opts v1.UpdateOptions) (*targetsv1alpha1.LogzMetricsTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "LogzMetricsTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.LogzMetricsTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1LogzMetricsTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) LogzTargets(namespace string) typedtargetsv1alpha1.LogzTargetInterface {
	return &wrapTargetsV1alpha1LogzTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "logztargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1LogzTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.LogzTargetInterface = (*wrapTargetsV1alpha1LogzTargetImpl)(nil)

func (w *wrapTargetsV1alpha1LogzTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.LogzTarget, opts v1.CreateOptions) (*targetsv1alpha1.LogzTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "LogzTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.LogzTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1LogzTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1LogzTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1LogzTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.LogzTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.LogzTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1LogzTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.LogzTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.LogzTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1LogzTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.LogzTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.LogzTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1LogzTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.LogzTarget, opts v1.UpdateOptions) (*targetsv1alpha1.LogzTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "LogzTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.LogzTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1LogzTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.LogzTarget, opts v1.UpdateOptions) (*targetsv1alpha1.LogzTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "LogzTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.LogzTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1LogzTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) OracleTargets(namespace string) typedtargetsv1alpha1.OracleTargetInterface {
	return &wrapTargetsV1alpha1OracleTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "oracletargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1OracleTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.OracleTargetInterface = (*wrapTargetsV1alpha1OracleTargetImpl)(nil)

func (w *wrapTargetsV1alpha1OracleTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.OracleTarget, opts v1.CreateOptions) (*targetsv1alpha1.OracleTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "OracleTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.OracleTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1OracleTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1OracleTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1OracleTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.OracleTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.OracleTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1OracleTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.OracleTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.OracleTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1OracleTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.OracleTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.OracleTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1OracleTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.OracleTarget, opts v1.UpdateOptions) (*targetsv1alpha1.OracleTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "OracleTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.OracleTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1OracleTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.OracleTarget, opts v1.UpdateOptions) (*targetsv1alpha1.OracleTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "OracleTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.OracleTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1OracleTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) SalesforceTargets(namespace string) typedtargetsv1alpha1.SalesforceTargetInterface {
	return &wrapTargetsV1alpha1SalesforceTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "salesforcetargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1SalesforceTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.SalesforceTargetInterface = (*wrapTargetsV1alpha1SalesforceTargetImpl)(nil)

func (w *wrapTargetsV1alpha1SalesforceTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.SalesforceTarget, opts v1.CreateOptions) (*targetsv1alpha1.SalesforceTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SalesforceTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SalesforceTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SalesforceTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1SalesforceTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1SalesforceTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.SalesforceTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SalesforceTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SalesforceTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.SalesforceTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SalesforceTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SalesforceTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.SalesforceTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SalesforceTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SalesforceTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.SalesforceTarget, opts v1.UpdateOptions) (*targetsv1alpha1.SalesforceTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SalesforceTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SalesforceTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SalesforceTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.SalesforceTarget, opts v1.UpdateOptions) (*targetsv1alpha1.SalesforceTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SalesforceTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SalesforceTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SalesforceTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) SendGridTargets(namespace string) typedtargetsv1alpha1.SendGridTargetInterface {
	return &wrapTargetsV1alpha1SendGridTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "sendgridtargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1SendGridTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.SendGridTargetInterface = (*wrapTargetsV1alpha1SendGridTargetImpl)(nil)

func (w *wrapTargetsV1alpha1SendGridTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.SendGridTarget, opts v1.CreateOptions) (*targetsv1alpha1.SendGridTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SendGridTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SendGridTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SendGridTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1SendGridTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1SendGridTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.SendGridTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SendGridTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SendGridTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.SendGridTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SendGridTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SendGridTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.SendGridTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SendGridTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SendGridTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.SendGridTarget, opts v1.UpdateOptions) (*targetsv1alpha1.SendGridTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SendGridTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SendGridTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SendGridTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.SendGridTarget, opts v1.UpdateOptions) (*targetsv1alpha1.SendGridTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SendGridTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SendGridTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SendGridTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) SlackTargets(namespace string) typedtargetsv1alpha1.SlackTargetInterface {
	return &wrapTargetsV1alpha1SlackTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "slacktargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1SlackTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.SlackTargetInterface = (*wrapTargetsV1alpha1SlackTargetImpl)(nil)

func (w *wrapTargetsV1alpha1SlackTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.SlackTarget, opts v1.CreateOptions) (*targetsv1alpha1.SlackTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SlackTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SlackTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SlackTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1SlackTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1SlackTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.SlackTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SlackTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SlackTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.SlackTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SlackTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SlackTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.SlackTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SlackTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SlackTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.SlackTarget, opts v1.UpdateOptions) (*targetsv1alpha1.SlackTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SlackTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SlackTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SlackTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.SlackTarget, opts v1.UpdateOptions) (*targetsv1alpha1.SlackTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SlackTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SlackTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SlackTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) SplunkTargets(namespace string) typedtargetsv1alpha1.SplunkTargetInterface {
	return &wrapTargetsV1alpha1SplunkTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "splunktargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1SplunkTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.SplunkTargetInterface = (*wrapTargetsV1alpha1SplunkTargetImpl)(nil)

func (w *wrapTargetsV1alpha1SplunkTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.SplunkTarget, opts v1.CreateOptions) (*targetsv1alpha1.SplunkTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SplunkTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SplunkTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SplunkTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1SplunkTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1SplunkTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.SplunkTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SplunkTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SplunkTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.SplunkTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SplunkTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SplunkTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.SplunkTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SplunkTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SplunkTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.SplunkTarget, opts v1.UpdateOptions) (*targetsv1alpha1.SplunkTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SplunkTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SplunkTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SplunkTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.SplunkTarget, opts v1.UpdateOptions) (*targetsv1alpha1.SplunkTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "SplunkTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.SplunkTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1SplunkTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) TektonTargets(namespace string) typedtargetsv1alpha1.TektonTargetInterface {
	return &wrapTargetsV1alpha1TektonTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "tektontargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1TektonTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.TektonTargetInterface = (*wrapTargetsV1alpha1TektonTargetImpl)(nil)

func (w *wrapTargetsV1alpha1TektonTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.TektonTarget, opts v1.CreateOptions) (*targetsv1alpha1.TektonTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "TektonTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.TektonTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1TektonTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1TektonTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1TektonTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.TektonTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.TektonTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1TektonTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.TektonTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.TektonTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1TektonTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.TektonTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.TektonTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1TektonTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.TektonTarget, opts v1.UpdateOptions) (*targetsv1alpha1.TektonTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "TektonTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.TektonTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1TektonTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.TektonTarget, opts v1.UpdateOptions) (*targetsv1alpha1.TektonTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "TektonTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.TektonTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1TektonTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) TwilioTargets(namespace string) typedtargetsv1alpha1.TwilioTargetInterface {
	return &wrapTargetsV1alpha1TwilioTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "twiliotargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1TwilioTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.TwilioTargetInterface = (*wrapTargetsV1alpha1TwilioTargetImpl)(nil)

func (w *wrapTargetsV1alpha1TwilioTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.TwilioTarget, opts v1.CreateOptions) (*targetsv1alpha1.TwilioTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "TwilioTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.TwilioTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1TwilioTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1TwilioTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1TwilioTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.TwilioTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.TwilioTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1TwilioTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.TwilioTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.TwilioTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1TwilioTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.TwilioTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.TwilioTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1TwilioTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.TwilioTarget, opts v1.UpdateOptions) (*targetsv1alpha1.TwilioTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "TwilioTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.TwilioTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1TwilioTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.TwilioTarget, opts v1.UpdateOptions) (*targetsv1alpha1.TwilioTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "TwilioTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.TwilioTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1TwilioTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) UiPathTargets(namespace string) typedtargetsv1alpha1.UiPathTargetInterface {
	return &wrapTargetsV1alpha1UiPathTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "uipathtargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1UiPathTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.UiPathTargetInterface = (*wrapTargetsV1alpha1UiPathTargetImpl)(nil)

func (w *wrapTargetsV1alpha1UiPathTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.UiPathTarget, opts v1.CreateOptions) (*targetsv1alpha1.UiPathTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "UiPathTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.UiPathTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1UiPathTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1UiPathTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1UiPathTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.UiPathTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.UiPathTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1UiPathTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.UiPathTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.UiPathTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1UiPathTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.UiPathTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.UiPathTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1UiPathTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.UiPathTarget, opts v1.UpdateOptions) (*targetsv1alpha1.UiPathTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "UiPathTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.UiPathTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1UiPathTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.UiPathTarget, opts v1.UpdateOptions) (*targetsv1alpha1.UiPathTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "UiPathTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.UiPathTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1UiPathTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapTargetsV1alpha1) ZendeskTargets(namespace string) typedtargetsv1alpha1.ZendeskTargetInterface {
	return &wrapTargetsV1alpha1ZendeskTargetImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "targets.triggermesh.io",
			Version:  "v1alpha1",
			Resource: "zendesktargets",
		}),

		namespace: namespace,
	}
}

type wrapTargetsV1alpha1ZendeskTargetImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedtargetsv1alpha1.ZendeskTargetInterface = (*wrapTargetsV1alpha1ZendeskTargetImpl)(nil)

func (w *wrapTargetsV1alpha1ZendeskTargetImpl) Create(ctx context.Context, in *targetsv1alpha1.ZendeskTarget, opts v1.CreateOptions) (*targetsv1alpha1.ZendeskTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "ZendeskTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ZendeskTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ZendeskTargetImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapTargetsV1alpha1ZendeskTargetImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapTargetsV1alpha1ZendeskTargetImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*targetsv1alpha1.ZendeskTarget, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ZendeskTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ZendeskTargetImpl) List(ctx context.Context, opts v1.ListOptions) (*targetsv1alpha1.ZendeskTargetList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ZendeskTargetList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ZendeskTargetImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *targetsv1alpha1.ZendeskTarget, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ZendeskTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ZendeskTargetImpl) Update(ctx context.Context, in *targetsv1alpha1.ZendeskTarget, opts v1.UpdateOptions) (*targetsv1alpha1.ZendeskTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "ZendeskTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ZendeskTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ZendeskTargetImpl) UpdateStatus(ctx context.Context, in *targetsv1alpha1.ZendeskTarget, opts v1.UpdateOptions) (*targetsv1alpha1.ZendeskTarget, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "targets.triggermesh.io",
		Version: "v1alpha1",
		Kind:    "ZendeskTarget",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &targetsv1alpha1.ZendeskTarget{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapTargetsV1alpha1ZendeskTargetImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}
